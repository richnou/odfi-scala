<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="Scala_Dev_Tools">Scala Dev Tools</h1><p>This module provides an up to date installation of Scala, as well as utility scripts</p><h2 id="Calling_scala">Calling scala</h2><p>Once setup, the module adds a standard scala installation to the path.
scalac, scala etc... should be accessible normally</p><h2 id="Scripting_Scala">Scripting Scala</h2><p>The <i>scala</i> startup script provides basic support for executing a file containing scala.
It lacks however a very few features which are provided by the <i>scala_script</i> improvement.</p><h3 id="Writing_a_simple_script">Writing a simple script</h3><p>To write a simple scala script, simply open a file, and use this template:</p><p><code class="scala">#!/usr/bin/env scala_script
println("This is scala here")
</code></p><h3 id="Augmenting_the_classpath">Augmenting the classpath</h3><p>The main problem with scripting scala, is that the script starts with the default Java + Scala classpath.
If you need some additional libraries, you could improve the classpath at runtime, but the additonal classes referenced in the script
would prevent it from compiling.
That is why, your classpath must be complete when starting the script.</p><p>To palliate this issue, a scala script may contain an embedded bootstrap script, which will be extracted an run prior to the main script.
The output of this script will be parsed for lines containing references to jar or folder files, each of which will be added to the main classpath</p><h4 id="Embedded_Bootstrap_Script">Embedded Bootstrap Script</h4><p>This template provides an embedded bootstrap script</p><p><code class="scala"></p><pre> #!/usr/bin/env scala_script
</pre><pre> __SCALA_CLASSPATH__
</pre><pre> HERE COMES THE BOOTSTRAP SCRIPT
</pre><pre> __EOF_SCALA_CLASSPATH__
</pre><pre> import my.user.library.MyClass
</pre><pre> println("This is scala here")
</pre><p></code></p><h4 id="Example:_Scala_Bootstrap">Example: Scala Bootstrap</h4><h4 id="Example:_Bash_Bootstrap_.3D">Example: Bash Bootstrap =</h4><h3 id="Scala_script_daemon">Scala script daemon</h3><p>The scala script daemon is a special shee bang that allows
sending the scala script to a runner daemon.
If no runner daemon is found, one is started for the current user</p><p>To use this feature simply write a script with following pattern:</p><p><code class="scala"></p><pre> #!/usr/bin/env scala_daemon_script
</pre><pre> ;----------------- Section 1
</pre><pre> println("This is scala here but compiled/run before Section 2")
</pre><pre> ;----------------- Section 2
</pre><pre> import my.user.library.MyClass
</pre><pre> println("This is scala here")
</pre><pre> ...
</pre><p></code></p><h4 id="Daemon_script_interpreter">Daemon script interpreter</h4><p>The daemon script interpreter works this way:</p><ul><li>Look for a unix socket in ${ODFI_DEV_SCALA_HOME}/script_runner.unix</li><li>If none is found:<ul><li>Start daemon script odfi_scala_script_runner.bash</li></ul></li><li>Send the script content to ${ODFI_DEV_SCALA_HOME}/daemon.unix using a simple UDP packet</li></ul><h4 id="Script_runner_daemon">Script runner daemon</h4><p>This is a simple scala script written with the scala_script interpreter:
The documentation is included in the code</p></body></html>